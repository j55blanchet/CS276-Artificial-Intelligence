from Maze import Maze
from time import sleep

HEURISTIC_NONADMISSIBLE_WEIGHT = 1.5
HEURISTIC_NONADMISSIBLE_CONVERGANCE_FACTOR = 1.5

class SensorlessProblem:

    def __init__(self, maze, goal_x, goal_y):
        self.goal = (goal_x, goal_y)
        self.maze = maze

        # Add all possible robot locations to the starting state
        start_state = set()
        for x in range(maze.width):
            for y in range(maze.height):
                if maze.is_floor(x, y):
                    start_state.add((x, y))

        self.start_state = self._normalize_state(start_state)

    def __str__(self):
        string =  "Blind robot problem: "
        return string

        # given a sequence of states (including robot turn), modify the maze and print it out.
        #  (Be careful, this does modify the maze!)

    @staticmethod
    def animate_path(maze, path, goal):
        print("Sensorless Problem")
        for state in path:    
            print(maze.string_sensorless(state, goal))
            sleep(1)

    def get_successors(self, state):

        moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        successors = []

        for dx, dy in moves:

            # Set of locations where the robot might be next turn, if it does this move
            next_state = set()
            for x, y in state:
                nx, ny = x + dx, y + dy

                # The robot ran into a wall, so it doesn't move
                if not self.maze.is_floor(nx, ny):
                    nx = x
                    ny = y

                if (nx, ny) in next_state:
                    # This location is already present in the next state. 
                    # Hopefully this gets hit a lot so the robot can
                    # figure out where it is.
                    continue
                
                next_state.add((nx, ny))
            
            
            next_state = self._normalize_state(next_state)

            # successors is a list of tuples in the form of (transition cost, succession state)
            successors.append((1, next_state))

        # there's no need to filter by legality, because there are no illegal states 
        # generated by the above algorithm
        return successors

    def is_goal(self, state):
        if len(state) != 1:
            return False
        
        return list(state)[0] == self.goal

    def _normalize_state(self, state):
        """Normalize the representation of the state so it can be
        hashed and so the potential locations can be iterated through

        Args:
            state (set): State to normalize

        Returns:
            Tuple[Tuple[int]]: Tuple containing all the potential locations
        """
        # We sort the set of options and convert it into a tuple 
            # so that it can be hashed and compared by the search algorithms
        state = list(state)
        state.sort()
        return tuple(state)
    
    def heuristic_convergance_distance(self, state):
        """Heuristic that calculates the maximum separation between any two 
        potential locations in the state. Logic is that we must perform at least
        `delta_x + delta_y` moves to converge the two potential locations before 
        we can arrive at a solution.

        Args:
            state (Tuple[Tuple[int]]): Problem state to calculate heuristic for

        Returns:
            int: Estimate of remaining path cost
        """
        assert len(state) >= 1

        ref_x, ref_y = state[0]
        max_x_diff = 0
        max_y_diff = 0

        for i in range(1, len(state)):
            x, y = state[i]
            max_x_diff = max(max_x_diff, abs(x - ref_x))
            max_y_diff = max(max_y_diff, abs(y - ref_y))
        
        return max_x_diff + max_y_diff

    def heuristic_goal_distance(self, state):
        """Heuristic that calculates the maximum distance between any
        of the potential locations in the state and the goal. Logic is that 
        all potential locations must converage and arrive the goal spot before 
        we can find a solution. 

        Args:
            state (Tuple[Tuple[int]]): Problem state to calculate heuristic for

        Returns:
            int: Estimate of remaining path cost
        """
        goal_x, goal_y = self.goal
        distance_x = 0
        distance_y = 0

        for x, y in state:
            distance_x = max(distance_x, abs(goal_x - x))
            distance_y = max(distance_y, abs(goal_y - y))


        return distance_x + distance_y

    def heuristic_composite(self, state):
        """Composite heuristic that combines convergance and goal_reaching heuristics. 
        Logic is that before we can arrive at a solution all potential locations must 
        converge and must reach the goal location. It's possible that every move will
        do some of both behaviors, so the heuristics can't be simply added together. 
        Therefore, the maximum heuristic value is returned.

        Args:
            state (Tuple[Tuple[int]]): Problem state to calculate heuristic for

        Returns:
            int: Estimate of remaining path cost
        """
        return max([
            self.heuristic_goal_distance(state),
            self.heuristic_convergance_distance(state)
        ])
    
    def heuristic_nonadmissible_weighted(self, state, weight=HEURISTIC_NONADMISSIBLE_WEIGHT, convergence_factor=HEURISTIC_NONADMISSIBLE_CONVERGANCE_FACTOR):
        """Heuristic designed for fast, but nonoptimal solving of large problem sizes.
        By combining the two heuristics, the algorithm is incentivized to find moves that
        both converge and move the robot closer to the goal. The heuristic is nonadmissible
        as it can easily (and frequently does) overestimate the cost to the goal.

        Args:
            state ([type]): [description]

        Returns:
            [type]: [description]
        """

        return weight * (self.heuristic_convergance_distance(state) * convergence_factor + self.heuristic_goal_distance(state))

## A bit of test code


# if __name__ == "__main__":

